 The project is built as a modular and fully differentiable system for feature-based topology optimization. At its core, the pill module defines geometric “pill” features—line segments with radii—that can be combined to form continuous density fields on a discretized grid. It provides analytical derivatives and Hessians of these fields, supports various smooth aggregation and boundary modes, and uses a global configuration context to keep grid size, bounds, transitions, and extensions consistent across computations. Numerical stability is carefully maintained through clipping, small regularizations, and smooth approximations to avoid discontinuities or singularities. The optimization_definition module formulates the optimization problem itself, introducing constraints for minimum and maximum segment lengths and exposing a complete nonlinear programming interface with objective, gradient, and Hessian evaluations compatible with IPOPT and SciPy solvers. It supports multiple objective formulations—least-squares, reward-only, and a saturating reward variant—and can log and visualize the evolution of the optimization process. The staged optimization runner orchestrates the entire process based on a JSON configuration: it initializes feature parameters, executes staged runs from orientation to convergence, applies geometric constraints, and manages solver options such as first-order or exact Hessians. Built-in heuristics automatically prune weak or redundant features using geometric and density-based metrics, optionally merging nearby or aligned elements to simplify the structure. A greedy additive refinement loop can extend the design by iteratively inserting new features, optimizing them locally and globally only if they improve the objective. Utility functions handle field resampling, parsing, and visualization—producing GIF animations, plots, and detailed logs of every iteration. Altogether, the code forms a coherent, experiment-driven optimization framework that transforms target density fields into compact, constraint-safe feature configurations through a sequence of analytical, heuristic, and incremental refinement stages.


 To run an optimization, the system requires a working Python environment with SciPy and all other dependencies installed. Once set up, a complete optimization can be started directly from the command line using a command such as:

python scripts/optimize.py density/files/5bar_80.density.xml opt_config/example_run.json --output_dir ./example_run

This call follows a simple structure: first the path to the Python script, then the path to the target density file (usually an XML file containing the physical density field), followed by the path to the optimization configuration in JSON format, and optionally an output directory where all results, logs, and plots will be saved. The configuration file defines how the optimization behaves—it specifies initialization strategies, feature counts, solver parameters, constraint settings, and post-processing stages. At the global level, parameters such as the boundary type, transition width, grid resolution, aggregation method, and penalty factors are set. Then, stage-specific sections define the optimization schedule: typically an orientation run (reward-based initialization) followed by one or more convergence runs (least-squares refinement). Additional blocks configure optional heuristics, which can prune or merge redundant features, and an additive refinement stage that can iteratively introduce new features if they improve the design.

Before the optimization can be launched, a corresponding density file must exist. These XML-based files describe the physical density distribution over a mesh domain as computed by an external finite-element or density-based solver such as CFS. They contain the discretized grid, material setup, boundary conditions, and results per element. Such a file cannot be written manually—it is generated by running the external CFS simulation through the provided Python helper run_cfs(mesh_file, config_file, output_file), which calls the CFS executable with a mesh definition and a simulation configuration. The mesh file (typically created via create_mesh.py) defines the spatial discretization—resolution, width, height, and type—while the CFS configuration (an XML file) specifies the physical problem setup: the domain geometry, material model, boundary conditions, forces, constraints, and the optimization or simulation parameters for the solver. The resulting .density.xml output from this process contains the elementwise pseudo-densities that serve as the target field for the feature-based optimization. In summary, the workflow proceeds as follows: first, a mesh and CFS configuration are used to generate a target density field; then, the Python optimization framework takes this field along with a JSON configuration and executes the multi-stage optimization, progressively building a compact, feature-based representation of the original density pattern.

 For questions please refer to: paju_99@web.de
